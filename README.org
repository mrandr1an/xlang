#+AUTHOR: Chris Liourtas
#+TITLE: A proof of concept programming language

* XLang About

* Design
** Codebase
#+begin_center
/Everything underlined in bold is supposed to be a rust object inside the xlang codebase./
#+end_center
Everything starts with an input /I/ where the user either with the /CLI(A), TUI(B)/ or even directly from the /STDIN(C)/ inputs a String of characters
into the xlang *_InputBuffer_*. This buffer holds a mutable reference of that String which is supposedly the source code that the user wants evaluated
in an /E/ way.

#+begin_src rust :session 
  pub struct InputBuffer<'a>{
   value: &'a mut String
  }
#+end_src

#+RESULTS:

Depending on /E/ the code must be evaluated differently so for now we are abstracting /E/ in an *_Configuration_* enum so we can incrementally develop
the project.
#+begin_src rust :session
  pub enum Configuration{
  Stdin,
  Compiled,
  Jit,
  }
#+end_src

#+RESULTS:

The input of the user and the configuration is essentially the users desired program. Because the word program insinuates the need for
visible (or not) user output or execution when it can just be a library/standalone code we use the word *_Resolvable_* to describe whatever
the struct that holds both the *_InputBuffer_* and the *_Configuration_* enum. 

#+begin_src rust :session
  pub struct Resorvable<'a>{
    input: InputBuffer<'a>,
    config: Configuration,
  }
#+end_src

#+RESULTS:
: error: Could not compile `cargoWPQJ6H`.

For a more specific term of what actually gets executed we have the *_Program_* trait.
#+begin_src rust
  pub trait Program<'a> {
   type BadExit;
   type GoodExit;
   fn run(&'a mut self) -> Result<Self::GoodExit, Self::BadExit>;
   fn eval(&'a mut self) -> Result<Self::GoodExit, Self::BadExit>;
   fn preprocess(&'a mut self) -> Result<Self::GoodExit, Self::BadExit>;
   fn output_to_string(&'a mut self) -> Result<String, Self::BadExit>;
  }

  impl<'a> Program<'a> for &'a String {
   /*  ... */
   
  }

  impl<'a> Program<'a> for Resorvable<'a> {
   /*  ... */
  }

#+end_src

#+RESULTS:
: error: Could not compile `cargoU4jiBH`.

To run or do anything else with a program you first need to turn it into an Abstract Syntax Tree, a datastructure that represents the source code of
said program. Now we get into the syntax of xlang and how it looks in the rust codebase:
- S-expressions
  Are either a *_Token_* that looks like ~(token)~ or a list of tokens ~(first second third fourth)~
  #+begin_src rust
    pub enum Sexpr<'a>{
	EndExpr,
	Token(Token<'a>),
	List{
	    car: Box::new(Sexpr<'a>),
	    cdr: Vec<Sexpr<'a>>,
	}
    } 
  #+end_src
** Language
* Goals
* Documentation, Updates, Help
